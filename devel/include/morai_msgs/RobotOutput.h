// Generated by gencpp from file morai_msgs/RobotOutput.msg
// DO NOT EDIT!


#ifndef MORAI_MSGS_MESSAGE_ROBOTOUTPUT_H
#define MORAI_MSGS_MESSAGE_ROBOTOUTPUT_H


#include <string>
#include <vector>
#include <memory>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace morai_msgs
{
template <class ContainerAllocator>
struct RobotOutput_
{
  typedef RobotOutput_<ContainerAllocator> Type;

  RobotOutput_()
    : drive_mode(0)
    , safe_mode_en(false)
    , is_obstacle(false)
    , is_enabled(0)
    , is_collision(false)
    , is_emg_stop(false)
    , is_protect_stop(false)
    , is_brake(false)
    , is_speed_limit_on_safe_mode(false)
    , is_muting(false)
    , attach_exist(false)
    , attach_mode(0)
    , is_attach_sig(false)  {
    }
  RobotOutput_(const ContainerAllocator& _alloc)
    : drive_mode(0)
    , safe_mode_en(false)
    , is_obstacle(false)
    , is_enabled(0)
    , is_collision(false)
    , is_emg_stop(false)
    , is_protect_stop(false)
    , is_brake(false)
    , is_speed_limit_on_safe_mode(false)
    , is_muting(false)
    , attach_exist(false)
    , attach_mode(0)
    , is_attach_sig(false)  {
  (void)_alloc;
    }



   typedef int32_t _drive_mode_type;
  _drive_mode_type drive_mode;

   typedef uint8_t _safe_mode_en_type;
  _safe_mode_en_type safe_mode_en;

   typedef uint8_t _is_obstacle_type;
  _is_obstacle_type is_obstacle;

   typedef int32_t _is_enabled_type;
  _is_enabled_type is_enabled;

   typedef uint8_t _is_collision_type;
  _is_collision_type is_collision;

   typedef uint8_t _is_emg_stop_type;
  _is_emg_stop_type is_emg_stop;

   typedef uint8_t _is_protect_stop_type;
  _is_protect_stop_type is_protect_stop;

   typedef uint8_t _is_brake_type;
  _is_brake_type is_brake;

   typedef uint8_t _is_speed_limit_on_safe_mode_type;
  _is_speed_limit_on_safe_mode_type is_speed_limit_on_safe_mode;

   typedef uint8_t _is_muting_type;
  _is_muting_type is_muting;

   typedef uint8_t _attach_exist_type;
  _attach_exist_type attach_exist;

   typedef int32_t _attach_mode_type;
  _attach_mode_type attach_mode;

   typedef uint8_t _is_attach_sig_type;
  _is_attach_sig_type is_attach_sig;





  typedef boost::shared_ptr< ::morai_msgs::RobotOutput_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::morai_msgs::RobotOutput_<ContainerAllocator> const> ConstPtr;

}; // struct RobotOutput_

typedef ::morai_msgs::RobotOutput_<std::allocator<void> > RobotOutput;

typedef boost::shared_ptr< ::morai_msgs::RobotOutput > RobotOutputPtr;
typedef boost::shared_ptr< ::morai_msgs::RobotOutput const> RobotOutputConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::morai_msgs::RobotOutput_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::morai_msgs::RobotOutput_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::morai_msgs::RobotOutput_<ContainerAllocator1> & lhs, const ::morai_msgs::RobotOutput_<ContainerAllocator2> & rhs)
{
  return lhs.drive_mode == rhs.drive_mode &&
    lhs.safe_mode_en == rhs.safe_mode_en &&
    lhs.is_obstacle == rhs.is_obstacle &&
    lhs.is_enabled == rhs.is_enabled &&
    lhs.is_collision == rhs.is_collision &&
    lhs.is_emg_stop == rhs.is_emg_stop &&
    lhs.is_protect_stop == rhs.is_protect_stop &&
    lhs.is_brake == rhs.is_brake &&
    lhs.is_speed_limit_on_safe_mode == rhs.is_speed_limit_on_safe_mode &&
    lhs.is_muting == rhs.is_muting &&
    lhs.attach_exist == rhs.attach_exist &&
    lhs.attach_mode == rhs.attach_mode &&
    lhs.is_attach_sig == rhs.is_attach_sig;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::morai_msgs::RobotOutput_<ContainerAllocator1> & lhs, const ::morai_msgs::RobotOutput_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace morai_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::morai_msgs::RobotOutput_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::morai_msgs::RobotOutput_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::morai_msgs::RobotOutput_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::morai_msgs::RobotOutput_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::morai_msgs::RobotOutput_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::morai_msgs::RobotOutput_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::morai_msgs::RobotOutput_<ContainerAllocator> >
{
  static const char* value()
  {
    return "eaa8f4689886d42e18ac9f19e4d67999";
  }

  static const char* value(const ::morai_msgs::RobotOutput_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xeaa8f4689886d42eULL;
  static const uint64_t static_value2 = 0x18ac9f19e4d67999ULL;
};

template<class ContainerAllocator>
struct DataType< ::morai_msgs::RobotOutput_<ContainerAllocator> >
{
  static const char* value()
  {
    return "morai_msgs/RobotOutput";
  }

  static const char* value(const ::morai_msgs::RobotOutput_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::morai_msgs::RobotOutput_<ContainerAllocator> >
{
  static const char* value()
  {
    return "int32 drive_mode\n"
"bool safe_mode_en\n"
"bool is_obstacle\n"
"int32 is_enabled\n"
"bool is_collision\n"
"bool is_emg_stop\n"
"bool is_protect_stop\n"
"bool is_brake\n"
"bool is_speed_limit_on_safe_mode\n"
"bool is_muting\n"
"bool attach_exist\n"
"int32 attach_mode\n"
"bool is_attach_sig\n"
;
  }

  static const char* value(const ::morai_msgs::RobotOutput_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::morai_msgs::RobotOutput_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.drive_mode);
      stream.next(m.safe_mode_en);
      stream.next(m.is_obstacle);
      stream.next(m.is_enabled);
      stream.next(m.is_collision);
      stream.next(m.is_emg_stop);
      stream.next(m.is_protect_stop);
      stream.next(m.is_brake);
      stream.next(m.is_speed_limit_on_safe_mode);
      stream.next(m.is_muting);
      stream.next(m.attach_exist);
      stream.next(m.attach_mode);
      stream.next(m.is_attach_sig);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RobotOutput_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::morai_msgs::RobotOutput_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::morai_msgs::RobotOutput_<ContainerAllocator>& v)
  {
    s << indent << "drive_mode: ";
    Printer<int32_t>::stream(s, indent + "  ", v.drive_mode);
    s << indent << "safe_mode_en: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.safe_mode_en);
    s << indent << "is_obstacle: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_obstacle);
    s << indent << "is_enabled: ";
    Printer<int32_t>::stream(s, indent + "  ", v.is_enabled);
    s << indent << "is_collision: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_collision);
    s << indent << "is_emg_stop: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_emg_stop);
    s << indent << "is_protect_stop: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_protect_stop);
    s << indent << "is_brake: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_brake);
    s << indent << "is_speed_limit_on_safe_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_speed_limit_on_safe_mode);
    s << indent << "is_muting: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_muting);
    s << indent << "attach_exist: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.attach_exist);
    s << indent << "attach_mode: ";
    Printer<int32_t>::stream(s, indent + "  ", v.attach_mode);
    s << indent << "is_attach_sig: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.is_attach_sig);
  }
};

} // namespace message_operations
} // namespace ros

#endif // MORAI_MSGS_MESSAGE_ROBOTOUTPUT_H
